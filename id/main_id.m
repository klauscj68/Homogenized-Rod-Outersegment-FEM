% Programma per la soluzione del problema della diffusione sui dischi attivati del bastoncello con incisure
% Code for solving the diffusion problem on activated disks of rod with incisures
function main_id

% % % profile on

% aggiunge alla path i file comuni e gli elementi
path('../common',path);
path('../elements',path);

% legge i dati
% data input
[R, H, n_sez, flag_geom_sp, dz_0, ...
    n_sd, Z_sd, ...
    n_inc, inc, ...
    taglia, tol_R, tol_angle, ...
    n_ref_cyto, n_ref_id, metodo_cyto, metodo_id, ...
    solver, theta, alpha, tol_fix, norma_inf, peak_delta, ...
    t_fin, n_step_t, downsample, ...
    plot_mesh, plot_num, plot_niagara, plot_pool , inspect, ...
    u_tent, v_tent, tol_stat, ...
    flag_model, flag_model_disc, flag_Ca_clamp, ...
    mode_time, mode_space, n_step_R, mu, lambda, ...
    nu_RE, nu_RG, cc_R_st, D_R_st, ...
    n_Phi, Phi, random_location, ...
    k_GE, cc_G_st, D_G_st, ...
    k_hyd, PDE_s, k_st, ...
    cc_E_st, D_E_st, k_E, ...
    MC_disk, ...
    n_sample, ...
    epsilon_0, nu, sigma, ...
    cc_u, kk_u, cc_v, kk_v, ...
    alpha_max, alpha_min, m_cyc, k_cyc, ...
    B_ca, F, j_cg_max, f_ca, m_cg, K_cg, ...
    j_ex_sat, K_ex]=data;





% costruisce la mesh
% mesh construction
[n_pd, n_int_pd, n_tri, n_os, n_p_inc, ...
         os2pd, inc2pd, pd2int_pd, p_pd, t_pd, ...
         n_ipd, p_ipd, p_ipd_bea, t_ipd, ipd2pd, ...
         n_pd_id, n_int_pd_id, n_tri_id, n_os_id, n_p_inc_id, ...
         os2pd_id, inc2pd_id, pd2int_pd_id, p_pd_id, t_pd_id, ...
         n_ipd_id, p_ipd_id, p_ipd_bea_id, t_ipd_id, ipd2pd_id, ...
         Z_s, sd2sez]=...
     genemesh(R, H, n_sez, flag_geom_sp, dz_0, ...
     n_sd, Z_sd, ...
     n_inc, inc, ...
     taglia, tol_R, tol_angle, n_ref_cyto, n_ref_id, ...
     plot_mesh, plot_num, inspect);

% % random walk
% confronto_MC_PDE(n_ipd_id, p_ipd_id, n_tri_id, t_ipd_id, ...
%      n_sd, n_inc, inc, ...
%      cc_R_st, D_R_st, ...
%      n_Phi, Phi, ...
%      tau, mode_time, ...
%      peak_delta, R, ...
%      inspect, plot_pool, plot_niagara, ...
%      t_fin, n_step_t, metodo_id, solver);
% stop





% predispone M per il calcolo della massa totale di diesterasi
[K, M] = assembla_ipd(n_ipd_id, n_tri_id, p_ipd_id, t_ipd_id);

% inizializza E_st e massa_E_st
E_st=cell(1,n_sd);
massa_E_st=cell(1,n_sd);
for d=1:n_sd
    E_st{d}=zeros(n_pd,n_sample,n_step_t/downsample+1);
    massa_E_st{d}=zeros(n_sample,n_step_t/downsample+1);
    massa_R_st{d}=zeros(n_sample,n_step_t/downsample+1,n_step_R);
end

% ciclo sui campioni random
for samp=1:n_sample

    fprintf('Campione %4i di %4i\n',samp,n_sample);
    
    % choose at random the locations of photoisomerizations, if requested
    if random_location
        for s=1:n_sd
            % rho is distributed in such a way that 
            % [rho*cos(beta);rho*sin(beta) is uniformly distributed on the disc
            rho=R*sqrt(rand(1,n_Phi(s)));
            beta=2*pi*rand(1,n_Phi(s));
            % update rho,beta into Phi{s}
            Phi{s}(1:2,:)=[rho; beta];
        end
    end

    % problema della creazione di R* ed E^* sui dischi speciali incisi
    % creation of R* and E* on incised special disk
    if MC_disk
        % metodo Monte Carlo semplificato
        % tasso di creazione di E*, nu_RE, da parte di R* dipendente solo dallo stato di R*
        % simplifie Monte Carlo method
        % rate of production of E*, vu_RE, depending only on the state of R*
        [time, R_st_id, E_st_id]=diffusione_ipd_MC(...
            n_ipd_id , n_tri_id , p_ipd_id, t_ipd_id, ...
            n_sd, n_inc, inc, ...
            D_E_st, D_R_st, ...
            n_step_R, nu_RE, k_E, tau, equal_step, mode_time, ...
            n_Phi, Phi, ...
            peak_delta, R,  ...
            plot_pool , inspect, ...
            t_fin, n_step_t);

    %     % import Monte-Carlo results for the problem of production and diffusion of E_st (E*) in the incised special discs
    %     [time, E_st_A]=diffusione_ipd_MC_A(R, n_pd, n_tri, p_pd, t_pd, ...
    %         n_sd, n_inc, inc, R, ...
    %         t_fin, n_step_t, plot_mesh, inspect);
    else
        % integrazione nel tempo del problema di creazione e diffusione di E_st (E*) nei dischi speciali incisi
        % time integration of the problem of production and diffusion of E_st (E*) in the incised special discs
        [time, R_st_id, G_st_id, E_st_id]=diffusione_ipd_PDE(...
            n_ipd_id , n_tri_id , p_ipd_id, t_ipd_id, ...
            n_sd, n_inc, inc, ...
            flag_model, flag_model_disc, ...
            cc_R_st, D_R_st, cc_G_st, D_G_st, cc_E_st, D_E_st, ...
            n_step_R, mu, lambda, nu_RE, nu_RG, ...
            k_E, k_GE, PDE_s, mode_time, mode_space, ...
            n_Phi, Phi, ...
            peak_delta, R,  ...
            plot_niagara, plot_pool , inspect, ...
            t_fin, n_step_t, metodo_id, solver, theta, alpha, tol_fix);
    end

    % mappa la soluzione del problema per E_st nei dischi speciali incisi sui dischi non incisi
    % in altri termini, prima media la soluzione del problema di diffusione sui due labbri del taglio di ogni incisura, 
    % poi interpola dalla mesh p_pd_id del disco inciso con raffittimento n_ref_id 
    % alla mesh p_pd del pivot disk del problema omogeneizzato, con
    % raffittimento n_ref_cyto
    % maps the solution of the problem for E_st in the incised special discs on the non-incised discs
    % in other words, first averages the solution of thediffusion problem on the two rim of each incisure, 
    % then interpolates from the mesh p_pd_id of the incised disc (refinement n_ref_id)
    % to the mesh p_pd of the pivot disk of the homogenized problem (refinement n_ref_cyto)
    [E_st_sample]=diffusione_ipd2pd(n_pd, p_pd, n_pd_id, p_pd_id, t_pd_id, ...
        n_sd, n_inc, inc2pd_id, ipd2pd_id, ...
        n_ref_cyto, n_ref_id, n_step_t, R, E_st_id);

    % % %     disp(['esperimento ',num2str(samp)])
    % salva
    for d=1:n_sd
        % la massa è calcolata sulla E_st_id, non cucita
        massa_E_st{d}(samp,:)=ones(1,n_ipd_id )*M*(E_st_id{d}(1:downsample:n_step_t+1,:))';
        % calcola la massa di R_st
        for cont=1:n_step_R
            massa_R_st{d}(samp,:,cont)=ones(1,n_ipd_id )*M*(R_st_id{d}(1:downsample:n_step_t+1,:,cont))';
        end
        % in E_st viene memorizzata la E_st cucita (E_st_sample)
        E_st{d}(:,samp,:)=(E_st_sample{d}(1:downsample:n_step_t+1,:))';
    end

% % % massa_E_st{1}(samp,:)
% % % [ones(1,n_ipd_id )*M*R_st_id{1}';...
% % %     ones(1,n_ipd_id )*M*G_st_id{1}';...
% % %     ones(1,n_ipd_id )*M*E_st_id{1}']
save advance samp
end
    

% salva su disco la distribuzione decimata di E_st, la sua massa
% ed i tempi corrispondenti
time_downsample=time(1:downsample:n_step_t+1);
save('E_st','E_st', 'massa_E_st',  'time_downsample')
save('mesh','p_pd', 't_pd',  'pd2int_pd')
%save('E_st', 'massa_E_st',  'time_downsample')
% % % profile viewer

return
